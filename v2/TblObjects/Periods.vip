//------------------------------------------------------------------------------
//                                                      (c) Корпорация Галактика
// Заработная плата по отделу
// Табличный объект расчетных периодов
//------------------------------------------------------------------------------

Interface Periods;

// Список периодов с данными
Table struct mtPeriods
(
  NRec:        comp,
  dBeg:        date,
  PlanDays:    byte,
  AvansDate:   date,
  PaymentDate: date,
  AvansRate:   double,
  PaymentRate: double
)
With index
(
  ByNRec = NRec (unique, surrogate),
  ByDate = dBeg (desc)
);


Create view from mtPeriods, mtPeriods mtPeriods2;

property dBeg:        date   absolute mtPeriods.dBeg;
property PlanDays:    byte   absolute mtPeriods.PlanDays;
property AvansDate:   date   absolute mtPeriods.AvansDate;
property PaymentDate: date   absolute mtPeriods.PaymentDate;
property AvansRate:   double absolute mtPeriods.AvansRate;
property PaymentRate: double absolute mtPeriods.PaymentRate;

index Sort auto;

public function PlanDaysPrev: byte;
{
  result := mtPeriods.PlanDays;

  if (GetFirst mtPeriods2 where (( mtPeriods.dBeg >> mtPeriods2.dBeg )) = tsOk)
    result := mtPeriods2.PlanDays;
}

public function Next: date;
{
  if (GetFirst mtPeriods2 ordered by index ByDate = tsOk)
    result := Add_Months(mtPeriods2.dBeg, 1);
  else
    result := date(1, 1, 2000);
}

public function CanDelete: boolean;
{
  if (GetFirst mtPeriods2 where (( mtPeriods.dBeg << mtPeriods2.dBeg )) = tsOk)
    if (GetFirst mtPeriods2 where (( mtPeriods.dBeg >> mtPeriods2.dBeg )) = tsOk)
    {
      message('Можно удалять только крайние периоды в списке.');
      result := false;
      exit;
    }

  result := (message('Удалить период?', Confirmation + YesNo) = cmYes);
}

public function Correct: boolean;
{
  if (mtPeriods.PlanDays < 18) or (mtPeriods.PlanDays > 22)
  {
    message('Количество рабочих дней должно быть в диапазоне от 18 до 22');
    result := false;
    exit;
  }

  if (GetFirst mtPeriods2 where (( Sub_Months(mtPeriods.dBeg, 1) >> mtPeriods2.dBeg )) = tsOk)
    if (GetFirst mtPeriods2 where (( Sub_Months(mtPeriods.dBeg, 1) == mtPeriods2.dBeg )) <> tsOk)
    {
      message('В списке периодов не должно быть разрывов.');
      result := false;
      exit;
    }

  if (GetFirst mtPeriods2 where (( Add_Months(mtPeriods.dBeg, 1) << mtPeriods2.dBeg )) = tsOk)
    if (GetFirst mtPeriods2 where (( Add_Months(mtPeriods.dBeg, 1) == mtPeriods2.dBeg )) <> tsOk)
    {
      message('В списке периодов не должно быть разрывов.');
      result := false;
      exit;
    }

  if (GetFirst mtPeriods2 where (( mtPeriods.NRec == mtPeriods2.NRec )) = tsOk)
  {
    var dTmp: date;
    dTmp := mtPeriods2.dBeg;
    if (GetFirst mtPeriods2 where (( Sub_Months(dTmp, 1) == mtPeriods2.dBeg )) = tsOk)
      if (GetFirst mtPeriods2 where (( Add_Months(dTmp, 1) == mtPeriods2.dBeg )) = tsOk)
      {
        message('В списке периодов не должно быть разрывов.');
        result := false;
        exit;
      }
  }

  result := true;
}

function IModify.doInsert : word;
{
  result := insert current mtPeriods;
}

function IModify.doUpdate : word;
{
  result := update current mtPeriods;
}

function IModify.doDelete : word;
{
  result := delete current mtPeriods;
}

implementation IModify.doFlush  abstract;

constructor Init;
{
  result := true;
  delete all mtPeriods;
}

public procedure Clear;
{
  delete all mtPeriods;
}

public function LoadXml(_e: IDomNode): boolean;
{
  ClearBuffer(#mtPeriods);
  if _e.GetFirstAttr
    do
    {
      case _e.FndAttr.Name of
        'rok:dBeg':        dBeg        := StrToDate(_e.FndAttr.Value, 'DD/MM/YYYY');
        'rok:PlanDays':    PlanDays    := byte(_e.FndAttr.Value);
        'rok:AvansDate':   AvansDate   := StrToDate(_e.FndAttr.Value, 'DD/MM/YYYY');
        'rok:PaymentDate': PaymentDate := StrToDate(_e.FndAttr.Value, 'DD/MM/YYYY');
        'rok:AvansRate':   AvansRate   := double(_e.FndAttr.Value);
        'rok:PaymentRate': PaymentRate := double(_e.FndAttr.Value);
      end;
    }
    while (_e.GetNextAttr);
  insert current mtPeriods;
  result := true;
}

public function SaveXml(_e: IDomNode): IDomNode;
{
  var xnode: IDomNode
  xnode := _e.AddNode('rok:Period');
  xnode.AddAttr('rok:dBeg='        + string(dBeg));
  xnode.AddAttr('rok:PlanDays='    + string(PlanDays));
  xnode.AddAttr('rok:AvansDate='   + string(AvansDate));
  xnode.AddAttr('rok:PaymentDate=' + string(PaymentDate));
  xnode.AddAttr('rok:AvansRate='   + DoubleToStr(AvansRate, '\4p[|-]3666666666~9999'));
  xnode.AddAttr('rok:PaymentRate=' + DoubleToStr(PaymentRate, '\4p[|-]3666666666~9999'));
  result := xnode;
}

public function LoadRok: boolean;
{
  result := false;

  if CheckNewRec
  {
    ClearBuffer(#mtPeriods);
    dBeg        := ReadDate;
    PlanDays    := ReadByte;
    AvansDate   := ReadDate;
    PaymentDate := ReadDate;
    AvansRate   := ReadDouble;
    PaymentRate := ReadDouble;
    insert current mtPeriods;
    result := true;
  }
}

public function SaveRok: boolean;
{
  result := true;
  StartNewRec;
  var b, b1, b2: byte;
  b := byte((((Year(dBeg) - 2000) * 12 + Month(dBeg) - 1) shl 5) + (PlanDays or 31));
  WriteByte(b);
  if (Day(AvansDate) < 18) or (Month(AvansDate) <> Month(dBeg)) or (Year(AvansDate) <> Year(dBeg))
    b1 := 0;
  else
    b1 := (Day(AvansDate) - 18);
  if (Day(PaymentDate) < 1) or (Day(PaymentDate) > 15) or (Month(PaymentDate) <> Month(Add_Months(dBeg, 1))) or (Year(PaymentDate) <> Year(Add_Months(dBeg, 1)))
    b2 := 0;
  else
    b2 := Day(PaymentDate);
  b := (b1 shl 4) + b2;
  WriteByte(b);
  WriteDouble(AvansRate);
  WriteDouble(PaymentRate);
}

end.
