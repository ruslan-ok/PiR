//------------------------------------------------------------------------------
//                                                      (c) Корпорация Галактика
// Заработная плата по отделу
// Просмотр информации
//------------------------------------------------------------------------------

#include Marker.vih
#include AtlProtocol.vih

Interface WageView 'Отдел разработки "Управление персоналом"' ('',, sci1478Esc);
  Show at(,, 125, 35);

var
  cNode: comp;

  cSotr: comp;
  sav_Mode: word;
  sav_cRec: byte;
  CurPerson: byte;
  ByteCounter: byte;
  yPersonId, yPeriodId: byte;
  wlog: AtlProtocol;

  mtPeriod:  IPeriod(Period) new;
  mtDepHist: IDepHist;
  mtDepart:  IDepart(Depart)   new;
  mtPost:    IPost(Post)       new;
  mtPerson:  IPerson(Person)   new;
  mtFioHist: IFioHist(FioHist) new;
  mtChild: IChild(Child) new;
  mtAppoint: IAppoint(Appoint) new;
  mtEducation: IEducation(Education) new;
  mtPersPer: IPersPer(PersPer) new;
  mtPayTitle: IPayTitle(PayTitle) new;
  mtNachisl: IPayment(Nachisl) new;
  mtPayment: IPayment(Payment) new;

  pMarker:   IMarker(marker)   new;

Table struct mtStruct
(
  NRec:   comp,
  Node:   comp,
  Period: byte,
  dBeg:   date,
  dEnd:   date,
  Name:   string,
  Mode:   byte,
  Depart: byte,
  Person: byte,
  Sort:   s100
)
with index
(
  mtStruct1 = NRec (unique, surrogate),
  mtStruct2 = Period + Node + Mode(desc) + Sort,
  mtStruct3 = Period + Mode + Depart,
  mtStruct4 = Period + Mode + Person
);

Table struct mtColTitle
(
  Num: longint,
  Name: string,
  PayTitle: byte
)
with index
(
  mtColTitle01 = Num,
  mtColTitle02 = Name
);

Table struct mtSpCol
(
  NRec: comp,
  Col: longint,
  Num: longint,
  ColNum: longint,
  Name: string
)
with index
(
  mtSpCol01 = NRec (surrogate),
  mtSpCol02 = Col + Num,
  mtSpCol03 = Col + Name
);

#ifdef NoPiR
Table struct KatSotr
(
  NRec: comp,
  FIO: string,
  EMail: string,
  Name: string
)
with index
(
  KatSotr01 = NRec (surrogate),
  KatSotr02 = FIO,
  KatSotr03 = Name
);
#end

Table struct mtNrecId
(
  wTable: word,
  NRec: comp,
  Id: byte
)
With index
(
  mtNrecId1 = wTable + NRec,
  mtNrecId2 = wTable + Id
);

Table struct mtIncrease
(
  FIO: string,
  Depart: string,
  Post: string,
  Employed: date,
  Appointed: date,
  Contract: date,
  Salary: double,
  Currency: string,
  LastSalInc: date,
  MonthsSalInc: word,
  ValueSalInc: double,
  LastPostInc: date,
  MonthsPostInc: word
)
with index
(
  ByFIO = FIO
);

Create view as select
  *
From
  mtPeriod (ByDate),
  mtDepHist,
  mtDepart (BySort),
  mtPost,
  mtFioHist,
  mtChild,
  mtAppoint,
  mtEducation,
  mtPerson,
  mtStruct,
  mtStruct SubStruct,
  mtStruct mtStruct2,
  mtPersPer,
  mtPayTitle,
  mtNachisl,
  mtPayment,
  mtColTitle,
  mtSpCol,
  KatSotr,
  mtNrecId,
  mtNrecId mtNrecId2,
  mtIncrease

Where ((
  mtPeriod.Id       == mtStruct.Period  and
  cNode             == mtStruct.Node    and

  mtStruct.Person   == mtPerson.Id      and

  mtPerson.Id       == mtFioHist.Person and
  mtPerson.Id       == mtChild.Person   and
  mtPerson.Id       == mtAppoint.Person and
  mtPerson.Id       == mtEducation.Person and

  mtPerson.Id       == mtPersPer.Person and
  mtPeriod.Id       == mtPersPer.Period and

  mtPerson.Id       == mtNachisl.Person and
  mtPeriod.Id       == mtNachisl.Period and

  mtPerson.Id       == mtPayment.Person and
  mtPeriod.Id       == mtPayment.Period and

  mtPeriod.Id       == SubStruct.Period and
  mtStruct.NRec     == SubStruct.Node   and

  cSotr             == KatSotr.NRec
))

Condition CurAppoint = ((mtPeriod.dBeg >= mtAppoint.dBeg) and ((mtAppoint.dEnd = ZeroDate) or (mtAppoint.dEnd > mtPeriod.dBeg)))
Condition SotrOnly = ((mtPeriod.Id = mtStruct.Period) and (mtStruct.Mode = 2) and (mtStruct.Name[1] <> '_') and (mtPersPer.FactDays > 0))

Bounds CurSotr     = mtPeriod.Id == mtStruct.Period and word(2) == mtStruct.Mode and CurPerson == mtStruct.Person
Bounds ViewDepHist = mtDepart.Id == mtDepHist.Depart
Bounds AppDep      = mtAppoint.Depart == mtDepart.Id
Bounds AppPost     = mtAppoint.Post   == mtPost.Id
Bounds SelDep      = root == mtDepart.Sort ordered by mtDepart.Sort
Bounds SelPost     = root == mtPost.Name ordered by mtPost.Name
;

property PersonId: byte read yPersonId;
property PeriodId: byte read yPeriodId;
var bDataChanged: boolean;
property DataChanged: boolean read bDataChanged write bDataChanged := result;

private function GetNachisl(_mode: byte): double; forward;
private function GetPayment(_mode: byte): double; forward;
private procedure BuildTree(_mode, _rec: byte); forward;
//private function GetDebtInRate: double; forward;
private function isHitPeriod(dateBeg, dateEnd, dateTest: date): boolean; forward;


Browse brPeriods ('',, sci1478EnEsc);
  Show at(,, 10,) Fixed_X;
  Table mtPeriod;
Fields
  mtPeriod.dBeg 'Период' ('Месяц и год расчетного периода'): [7, 'MM.YYYY'], Protect;
End;

Tree trFilling ('',, sci1478EscTree);
  Show at(11,, 39,);
  Table mtStruct;
  recMarker = pMarker {mtStruct.NRec};
Fields
  mtStruct.Name 'Подразделение или ФИО' ('Наименование подразделения или ФИО работника'): [25], Protect;
End;


TableEvent
  Table mtPeriod;

cmPositionChanged:
{
  if (GetFirst mtStruct2 where (( mtPeriod.Id == mtStruct2.Period and
                                  comp(0)     == mtStruct2.Node )) <> tsOk)
    BuildTree(sav_Mode, sav_cRec);
  else
  {
    var poz: boolean = false;

    if (sav_Mode = 1)
      poz := (GetFirst mtStruct2 where (( mtPeriod.Id == mtStruct2.Period and
                                          sav_Mode    == mtStruct2.Mode   and
                                          sav_cRec    == mtStruct2.Depart )) = tsOk);
    else
      poz := (GetFirst mtStruct2 where (( mtPeriod.Id == mtStruct2.Period and
                                          sav_Mode    == mtStruct2.Mode   and
                                          sav_cRec    == mtStruct2.Person )) = tsOk);
    if poz
      TreeJumpToRecord(trFilling, mtStruct2.NRec);
    else
      TreeGetFirst(trFilling);
  }
}

End;

TableEvent
  Table mtStruct;

cmTreeTop:
  cNode := 0;

cmTreeUp:
  cNode := mtStruct.Node;

cmTreeDown:
  cNode := mtStruct.NRec;

cmTreeNodeType:
{
  var yType: byte; // лист или папка (открытая или закрытая)
  yType := ntfText;
  if (isValid(tnmtStruct) and isValid(tnSubStruct))
    if (TreeNodeIsOpen(trFilling))
      yType := ntfOpen;
    else
      yType := ntfClose;

  TreeSetNodeType(trFilling, yType);
}

cmTreeNeedOwner:
  TreeJumpToRecord(trFilling, mtStruct.Node);

cmPositionChanged:
{
  sav_Mode := mtStruct.Mode;
  sav_cRec := if(sav_Mode = 1, mtStruct.Depart, mtStruct.Person);
}

End;

TabbedSheet right tsInfo;
  show at(40,,,);

Screen scInfo 'Основное' ('',, sci178Esc);
  table mtPersPer;
Fields
  mtAppoint.dBeg:       protect;
  mtAppoint.dEnd:       protect;
  mtAppoint.Salary:     [13.2,'\2p[|-]366`666`666~99'], protect;
  mtAppoint.Currency:   skip;
  mtPersPer.SalaryRate: [13.4,'\4p[|-]366`666~9999'], noProtect;
  mtDepart.Name:        protect;
  mtPost.Name:          protect;
  mtPeriod.PlanDays:    protect;
  mtPersPer.FactDays:   noProtect;

  mtPersPer.Privilege: [13.2,'\2p[|-]366`666`666.88'], noProtect;

  (mtPersPer.DebtIn / mtPeriod.DebtInRate /*GetDebtInRate*/) ('',, sci178Esc): [13.2,'\2p[|-]366`666`666.88'], protect;
  mtPersPer.DebtIn ('',, sci1478Esc): [13.2,'\2p[|-]366`666`666.88'], noProtect;

  GetNachisl(cgUSD): [13.2,'\2p[|-]366`666`666.88'], protect;
  GetNachisl(cgBYN): [13.2,'\2p[|-]366`666`666.88'], protect;

  GetPayment(cgUSD): [13.2,'\2p[|-]366`666`666.88'], protect;
  GetPayment(cgBYN): [13.2,'\2p[|-]366`666`666.88'], protect;

  (mtPersPer.DebtOut / mtPeriod.PaymentRate) ('',, sci178Esc): [13.2,'\2p[|-]366`666`666.88'], protect;
  mtPersPer.DebtOut ('',, sci1478Esc): [13.2,'\2p[|-]366`666`666.88'], noProtect;
<<

   `Назначение с`     .@@@@@@@@@@@@                  `Контракт до` .@@@@@@@@@@@@
   `Оклад`            .@@@@@@@@@@@@  .@@@@@@@@@@@@    `Курс оклада`.@@@@@@@@@@@@
   `Отдел`            .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   `Должность`        .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

   `Дней план`        .@@@@@@@@@@@@                    `Дней факт` .@@@@@@@@@@@@

                                USD            BYN  `Льгота по ПН` .@@@@@@@@@@@@
   `Входящий остаток` .@@@@@@@@@@@@  .@@@@@@@@@@@@
   `Начислено`        .@@@@@@@@@@@@  .@@@@@@@@@@@@
   `Выплачено`        .@@@@@@@@@@@@  .@@@@@@@@@@@@
   `Исходящий остаток`.@@@@@@@@@@@@  .@@@@@@@@@@@@
>>
End;

Browse brNachisl 'Начисления';
  table mtNachisl;
Fields
  mtNachisl.GetTitleName  'Описание':    [20], Protect;
  mtNachisl.Payed         'Дата':        [10], Protect;
  mtNachisl.Value         'Сумма':       [13.2,'\2p[|-]366`666`666~99'], Protect;
  mtNachisl.Currency      'Валюта':      [ 5], [list cgBYN 'BYN', cgUSD 'USD'], Protect;
  mtNachisl.Rate          'Курс':        [13.4,'\4p[|-]366`666~9999'], Protect;
  mtNachisl.Info          'Комментарий': [20], Protect;
End;

Browse brPayment 'Выплаты';
  table mtPayment;
Fields
  mtPayment.GetTitleName 'Описание':    [20], Protect;
  mtPayment.Payed        'Дата':        [10], Protect;
  mtPayment.Value        'Сумма':       [13.2,'\2p[|-]366`666`666~99'], Protect;
  mtPayment.Currency     'Валюта':      [ 5], [list cgBYN 'BYN', cgUSD 'USD'], Protect;
  mtPayment.Rate         'Курс':        [13.4,'\4p[|-]366`666~9999'], Protect;
  mtPayment.Info         'Комментарий': [20], Protect;
End;

Browse brAppoints 'Назначения' ('',, sci1478Esc);
  table mtAppoint;
Fields
  {font = {color = if(isHitPeriod(mtAppoint.dBeg, mtAppoint.dEnd, mtPeriod.dBeg), 0, ColorSysGray)}};
  mtAppoint.dBeg     'Назначен с':    [15], Protect, {font = {backColor = if(mtAppoint.CorrectPer, 0, ColorError)}};
  mtAppoint.dEnd     'Контракт до':   [15], Protect;
  mtAppoint.Salary   'Оклад':         [13.2,'\2p[|-]366`666`666~99'], Protect;
  mtAppoint.Currency 'Вал.':          [ 5], Protect;
  mtDepart.Name      'Подразделение': [15], Protect;
  mtPost.Name        'Должность':     [25], Protect;
End;

End; // tsInfo

#include ReportFuncs.vpp

#include Period.vpp
#include Depart.vpp
#include DepHist.vpp
#include Post.vpp
#include Person.vpp
#include NewStruct.vpp
#include PersPer.vpp
#include PayTitle.vpp
#include Nachisl.vpp
#include Payment.vpp
#include Appoint.vpp

private procedure DoSetStream(_stream: TPtr);
{
  mtPeriod.SetStream(_stream);
  mtDepart.SetStream(_stream);
  mtDepHist.SetStream(_stream);
  mtPost.SetStream(_stream);
  mtPayTitle.SetStream(_stream);
  mtPerson.SetStream(_stream);
  mtFioHist.SetStream(_stream);
  mtChild.SetStream(_stream);
  mtAppoint.SetStream(_stream);
  mtEducation.SetStream(_stream);
  mtPersPer.SetStream(_stream);
  mtNachisl.SetStream(_stream);
  mtPayment.SetStream(_stream);
}

#include Export.vpp
#include Import.vpp

#include ReportBySotr.vpp
#include ReportByMonth.vpp
#include ReportOwertime.vpp
#include ReportIncrease.vpp

#include DoSend.vpp
#include DupCorrector.vpp

private function isHitPeriod(dateBeg, dateEnd, dateTest: date): boolean;
{ // проверяет попадает ли dateTest в период
  result := true;

  if (dateTest = ZeroDate)
    exit;

  if ((dateBeg = ZeroDate) and (dateEnd = ZeroDate))
    exit;

  if ((dateTest >= dateBeg) and (dateEnd = ZeroDate))
    exit;

  if ((dateTest <= dateEnd) and (dateBeg = ZeroDate))
    exit;

  if ((dateEnd <> ZeroDate) and (dateTest <= dateEnd) and (dateBeg <> ZeroDate) and (dateTest >= dateBeg))
    exit;

  result := false;
}

private procedure ScanAppoint(_dep: byte; _dst: comp);
{
  PushPos(tnmtAppoint);
  PushPos(tnmtStruct);
  _loop mtAppoint where (( _dep           == mtAppoint.Depart and
                           mtPeriod.dBeg >>= mtAppoint.dBeg ))
  {
    if ((mtAppoint.dEnd <> ZeroDate) and (mtAppoint.dEnd < mtPeriod.dBeg))
      continue;

    if (GetFirst mtPerson where (( mtAppoint.Person == mtPerson.Id )) <> tsOk)
      continue;

    insert mtStruct set mtStruct.Period := mtPeriod.Id,
                        mtStruct.Node   := _dst,
                        mtStruct.Mode   := 2,
                        mtStruct.dBeg   := mtAppoint.dBeg,
                        mtStruct.dEnd   := mtAppoint.dEnd,
                        mtStruct.Person := mtAppoint.Person,
                        mtStruct.Name   := mtPerson.FIO,
                        mtStruct.Sort   := LPadCh(string(mtPerson.Sort), '0', 6);

  }
  PopPos(tnmtStruct);
  PopPos(tnmtAppoint);
}

private procedure ScanDepHist(_src: byte; _dst: comp);
{
  PushPos(tnmtDepHist);
  _loop mtDepHist where (( _src           == mtDepHist.Node and
                           mtPeriod.dBeg >>= mtDepHist.dBeg ))
  {
    if ((mtDepHist.dEnd <> ZeroDate) and (mtDepHist.dEnd < mtPeriod.dBeg))
      continue;

    if (GetFirst mtDepart where (( mtDepHist.Depart == mtDepart.Id )) <> tsOk)
      continue;

    insert mtStruct set mtStruct.Period := mtPeriod.Id,
                        mtStruct.Node   := _dst,
                        mtStruct.Mode   := 1,
                        mtStruct.dBeg   := mtDepHist.dBeg,
                        mtStruct.dEnd   := mtDepHist.dEnd,
                        mtStruct.Depart := mtDepHist.Depart,
                        mtStruct.Name   := mtDepart.Name,
                        mtStruct.Sort   := string(mtDepart.Sort);
    ScanAppoint(mtDepHist.Depart, mtStruct.NRec);
    ScanDepHist(mtDepHist.Depart, mtStruct.NRec);
  }
  PopPos(tnmtDepHist);
}

private procedure BuildTree(_mode, _rec: byte);
{
  if (mtDepHist = NullRef)
    exit;

  StartNewVisual(vtRotateVisual, vfTimer + vfBreak + vfConfirm, 'Построение иерархии', 1);
  ResetBounds(tnmtStruct);
  delete all mtStruct where (( mtPeriod.Id == mtStruct.Period ));

  ScanDepHist(0, 0);

  SetBounds(tnmtStruct);

  var cGoto: comp = 0;

  if (_mode <> 0) and (_rec <> 0)
  {
    if (_mode = 1)
      if (GetFirst mtStruct where (( mtPeriod.Id == mtStruct.Period and
                                     _mode == mtStruct.Mode and
                                     _rec  == mtStruct.Depart )) = tsOk)
        cGoto := mtStruct.NRec;

    if (_mode = 2)
      if (GetFirst mtStruct where (( mtPeriod.Id == mtStruct.Period and
                                     _mode == mtStruct.Mode and
                                     _rec  == mtStruct.Person )) = tsOk)
        cGoto := mtStruct.NRec;
  }

  if TreeGetFirst(trFilling)
  {
    if (_mode = 0) or (_rec = 0)
      if isValid(tnmtStruct)
        cGoto := mtStruct.NRec;

    do
      TreeOpenNode(trFilling);
    while TreeGetNext(trFilling) and (TreeLevel(trFilling) > 0);
    TreeGetFirst(trFilling);
  }

  TreeJumpToRecord(trFilling, cGoto);

  RereadRecord(tnmtStruct);

  StopVisual;
}

private function GetNachisl(_mode: byte): double;
{
  result := 0;

  _loop mtNachisl
    case _mode of
      cgUSD: result += mtNachisl.inUSD;
      cgBYN: result += mtNachisl.inBYN;
    end;
}

private function GetPayment(_mode: byte): double;
{
  result := 0;

  _loop mtPayment
    case _mode of
      cgUSD: result += mtPayment.inUSD;
      cgBYN: result += mtPayment.inBYN;
    end;
}

private procedure DoPick;
{
  case CurField of

    #mtDepart.Name:
    {
      cSelectedDep := mtAppoint.Depart;
      RunWindowModal(wnPickDepart);
      if (cSelectedDep <> 0)
        set mtAppoint.Depart := cSelectedDep;
    }

    #mtPost.Name:
    {
      cSelectedPost := mtAppoint.Post;
      RunWindowModal(wnPickPost);
      if (cSelectedPost <> 0)
        set mtAppoint.Post := cSelectedPost;
    }

  end;
}

private procedure DoDel;
{
  case CurField of
    #mtDepart.Name: set mtAppoint.Depart := 0;
    #mtPost.Name:   set mtAppoint.Post   := 0;
  end;
}

private function GenerateNewId(_table: word): byte;
{
  if (GetLast mtNrecId2 where (( _table == mtNrecId2.wTable )) ordered by index mtNrecId2 <> tsOk)
    result := 1;
  else
    result := mtNrecId2.Id + 1;
}

public function GetId(_table: word; _nrec: comp): byte;
{
  if (GetFirst mtNrecId where (( _table == mtNrecId.wTable and
                                 _nrec  == mtNrecId.NRec )) <> tsOk)
  {
    ClearBuffer(#mtNrecId);
    mtNrecId.wTable := _table;
    mtNrecId.NRec := _nrec;
    mtNrecId.Id := GenerateNewId(_table);
    insert current mtNrecId;
  }

  result := mtNrecId.Id;
}

public function GetTitleId(_title: string): byte;
{
  result := mtPayTitle.GetId(_title);
}

public function GetTitleName(_title: byte): string;
{
  result := '';
  if (GetFirst mtPayTitle where (( _title == mtPayTitle.Id )) = tsOk)
    result := mtPayTitle.Name;
}

public function CheckLineLen: boolean;
{
  result := false;
  ByteCounter++;
  if (ByteCounter >= 180)
  {
    result := true;
    ByteCounter := 0;
  }
}

public procedure Log(_type: word; _mess: string);
{
  if (wDetProt <> 0)
    wlog.LogLine(_type, _mess);
}

HandleEvent

cmInit:
{
  ByteCounter := yPersonId := yPeriodId := 0;

  mtDepHist := IDepHist(new(DepHist, Init2(mtDepart)));
  mtPeriod.Clear(IWageView(self));
  mtDepart.Clear(IWageView(self));
  mtDepHist.Clear(IWageView(self));
  mtPost.Clear(IWageView(self));
  mtPerson.Clear(IWageView(self));
  mtFioHist.Clear(IWageView(self));
  mtChild.Clear(IWageView(self));
  mtAppoint.Clear(IWageView(self));
  mtEducation.Clear(IWageView(self));
  mtPersPer.Clear(IWageView(self));
  mtPayTitle.Clear(IWageView(self));
  mtNachisl.Clear(IWageView(self));
  mtPayment.Clear(IWageView(self));
/*
  ClearBuffer(#mtPeriod);
  mtPeriod.dBeg := date(1,8,2018);
  mtPeriod.Id := byte((Year(mtPeriod.dBeg) - 2009) * 12 + Month(mtPeriod.dBeg) - 1); //PeriodToId(mtPeriod.dBeg);
  mtPeriod.PlanDays := 22;
  //mtPeriod.Correct;
  insert current mtPeriod;

  insert mtDepart set mtDepart.Name := 'Depart-1';
  insert mtDepHist set mtDepHist.dBeg := date(1,8,2018), mtDepHist.Depart := mtDepart.Id;
  //insert mtStruct set mtStruct.Period := mtPeriod.Id, mtStruct.Mode := 1, mtStruct.Name := mtDepart.Name, mtStruct.Depart := mtDepart.Id;
  //insert mtStruct set mtStruct.Period := mtPeriod.Id, mtStruct.Mode := 1, mtStruct.Name := 'Depart-1', mtStruct.Depart := 1;
  //cNode := mtStruct.NRec;

  insert mtPost set mtPost.Name := 'Post-1';

  insert mtPerson set mtPerson.FIO := 'Person-1', mtPerson.Login := 'Login-1';
  insert mtAppoint set mtAppoint.Person := mtPerson.Id, mtAppoint.dBeg := date(1,8,2018), mtAppoint.Depart := mtDepart.Id, mtAppoint.Post := mtPost.Id;
  //insert mtStruct set mtStruct.Period := mtPeriod.Id, mtStruct.Mode := 2, mtStruct.Name := mtPerson.FIO, mtStruct.Person := mtPerson.Id, mtStruct.Node := cNode;
  //insert mtStruct set mtStruct.Period := mtPeriod.Id, mtStruct.Mode := 2, mtStruct.Name := 'Person-1', mtStruct.Person := 1, mtStruct.Node := cNode;
  insert mtPersPer set mtPersPer.Person := mtPerson.Id, mtPersPer.Period := mtPeriod.Id, mtPersPer.FactDays := 20;

  insert mtPerson set mtPerson.FIO := 'Person-2', mtPerson.Login := 'Login-2';
  insert mtAppoint set mtAppoint.Person := mtPerson.Id, mtAppoint.dBeg := date(1,8,2018), mtAppoint.Depart := mtDepart.Id, mtAppoint.Post := mtPost.Id;
  //insert mtStruct set mtStruct.Period := mtPeriod.Id, mtStruct.Mode := 2, mtStruct.Name := mtPerson.FIO, mtStruct.Person := mtPerson.Id, mtStruct.Node := cNode;
  //insert mtStruct set mtStruct.Period := mtPeriod.Id, mtStruct.Mode := 2, mtStruct.Name := 'Person-2', mtStruct.Person := 2, mtStruct.Node := cNode;
  insert mtPersPer set mtPersPer.Person := mtPerson.Id, mtPersPer.Period := mtPeriod.Id, mtPersPer.FactDays := 19;
  cNode := 0;

  ClearBuffer(#mtPeriod);
  mtPeriod.dBeg := date(1,7,2018);
  mtPeriod.PlanDays := 22;
  mtPeriod.Id := byte((Year(mtPeriod.dBeg) - 2009) * 12 + Month(mtPeriod.dBeg) - 1); //PeriodToId(mtPeriod.dBeg);
//  mtPeriod.Correct;
  insert current mtPeriod;
*/
  PushBounds(tbAppDep);
  PushBounds(tbAppPost);
  TreeGetFirst(trFilling);
  RereadRecord;
  PushConditionForLeave(tcCurAppoint, tnmtAppoint);
  SetTitle('Отдел разработки "Управление персоналом" [+]');
  AutoImport;

  if isValid(#mtPeriod)
    SelectFormat(trFilling);

  bDataChanged := false;
}

cmDone:
  AutoExport;

cmChangeTabbedSheetFormat:
  if (Target = brAppoints)
  {
    PopConditionForLeave(tcCurAppoint, tnmtAppoint);
    SetTitle('Отдел разработки "Управление персоналом" [-]');
    RereadRecord;
  }
  else
  {
    PushConditionForLeave(tcCurAppoint, tnmtAppoint);
    SetTitle('Отдел разработки "Управление персоналом" [+]');
    RereadRecord;
  }

cmEdit:
  case CurTable of
    #mtStruct:
      if isValid(tnmtStruct)
        case mtStruct.Mode of
          1: RunWindowModal(wnDepart);
          2: RunWindowModal(wnPersList);
        end;
    #mtNachisl:
      RunWindowModal(wnNachisl);
    #mtPayment:
      RunWindowModal(wnPayment);
    #mtAppoint:
      RunWindowModal(wnAppoint);
    #mtPersPer:
      case CurField of
        #mtPersPer.DebtIn:
          RunWindowModal(wnDebtIn);
        #mtPersPer.DebtOut:
          RunWindowModal(wnDebtOut);
      end;
    #mtPeriod:
      RunWindowModal(wnPeriod);
  end;

cmAlt1:
  RunWindowModal(wnDepHist);

cmAddNewRec:
  if (CurTable = tnmtStruct)
  {
    abort;
    RunWindowModal(wnNewStruct);
    //BuildTree;
  }

cmInsert:
  PutCommand(cmEdit);

cmPick:
  DoPick;

cmDelOnProtect:
  DoDel;

cmHotKeys:
  PutHotCommand(RunMenu('mnWage'));

cmAccording:
{
  if (not isValid(#mtPeriod))
  {
    message('Не определен период');
    exit;
  }

  wMonth := Month(mtPeriod.dBeg);
  wYear  := Year(mtPeriod.dBeg);

  if ((Month(Cur_Date) = 1) and ((wMonth <> 12) or (wYear <> (Year(Cur_Date)-1)))) or
     ((Month(Cur_Date) > 1) and ((wMonth <> (Month(Cur_Date)-1)) or (wYear <> Year(Cur_Date))))
  {
    if (message('Подозрение на попытку отправки расчетников за предыдущий период - ' + DateToStr(mtPeriod.dBeg, 'month YYYY') + ' г.'#13#13 +
                'Отменить операцию?', Confirmation + YesNo) = cmYes)
      exit;
  }

  if (pMarker.Count = 0) and (mtStruct.Mode <> 2)
  {
    message('Нет помеченных сотрудников');
    exit;
  }

  DoSend;
}

cmExp:
  RunWindowModal(wnExport);

cmImp:
  RunWindowModal(wnImport);

#ifdef NoPiR
cmCalc:
#else
cmCtrlQ:
#end
  if isValid(tnmtStruct)
    BuildTree(mtStruct.Mode, if(mtStruct.Mode = 1, mtStruct.Depart, mtStruct.Person));
  else
    BuildTree(0, 0);

cmValue9:
  ReportBySotr;

cmValue11:
  ReportByMonth;

cmValue12:
  ReportOwertime;

cmValue13:
  ReportIncrease;

cmValue10:
  DupCorrector;
/*
cmValue13:
{
  var fRate: double = 0;
  PushPos(#mtPeriod);
  _loop backward mtPeriod
  {
    mtPeriod.DebtInRate := fRate;
    update current mtPeriod;
    fRate := mtPeriod.PaymentRate;
  }
  PopPos(#mtPeriod);
  message('done');
}
*/
End;
End.

mnWage menu
{
#ifdef NoPiR
 - 'Обновить иерархию', cmCalc, 'Пререстроение иерархии',, 'Ctrl+Q',  kbCtrlQ, sci1Esc;
#else
 - 'Обновить иерархию', cmCtrlQ, 'Пререстроение иерархии',, 'Ctrl+Q',  kbCtrlQ, sci1Esc;
#end
 ------;
 - 'Отправить', cmAccording, 'Отправить по почте',, 'Alt+S',  kbAltS, sci1Esc;
 - 'Экспорт', cmExp, 'Экспорт',, 'Alt+O', kbAltO, sci1Esc,,,, bmpExpDoc;
 - 'Импорт',  cmImp, 'Импорт',,  'Alt+I', kbAltI, sci1Esc,,,, bmpImpDoc;
 ------;
 - 'Отчет по сотруднику', cmValue9, 'Контрольный отчет по сотруднику за период',,,, sci1Esc;
 - 'Отчет по всем за месяц', cmValue11, 'Контрольный отчет по всем сотрудникам за выбранный месяц',,,, sci1Esc;
 - 'Сверхурочные', cmValue12, 'Сверхурочные',,,, sci1Esc;
 - 'Повышения', cmValue13, 'Повышения',,,, sci1Esc;
 ------;
 - 'Корректор', cmValue10, 'Проверка и корректировка дублей в начислениях и выплатах',,,, sci1Esc;
// - 'Курс зачета с прошлого месяца', cmValue13, 'Инициализация курсов зачета с прошлого месяца',,,, sci1Esc;
}
