//------------------------------------------------------------------------------
//                                                      (c) Корпорация Галактика
// Заработная плата по отделу
// Реализация кодера Base64
//------------------------------------------------------------------------------

#include Base64.vih

Interface Base64;

Const
  EncodingTable64: string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
End;

var i, cc, step, ndx: byte;

private procedure DoStep(var _res: string);
{
  case step of

    0:
    {
      ndx := ((cc shr 2) and 3Fh);
      _res += EncodingTable64[ndx+1];
      ndx := ((cc shl 4) and 30h);
      step := 1;
    }

    1:
    {
      ndx := ndx or ((cc shr 4) and 0Fh);
      _res += EncodingTable64[ndx+1];
      ndx := ((cc shl 2) and 3Ch);
      step := 2;
    }

    2:
    {
      ndx := ndx or ((cc shr 6) and 03h);
      _res += EncodingTable64[ndx+1];
      ndx := (cc and 3Fh);
      _res += EncodingTable64[ndx+1];
      step := 0;
    }

  end;
}

public function Encode(_data: string): string;
{
  result := '';
  step := 0;

  for (i := 1; i <= length(_data); i++)
  {
    cc := ord(_data[i]);
    DoStep(result);
  }

  if (step <> 0)
  {
    cc := 0;
    DoStep(result);
  }
}

private function GetPos64(_value: char): byte;
{
  result := 0;
  var k: byte;
  for (k := 1; k <= length(EncodingTable64); k++)
  {
    if (EncodingTable64[k] = _value)
    {
      result := k-1;
      exit;
    }
  }
  message('Base64: недопустимый символ во входном потоке.');
}

public function Decode(_data: string): string;
{
  result := '';
  step := 0;

  for (i := 1; i <= length(_data); i++)
  {
    cc := GetPos64(_data[i]);

    case step of

      0:
      {
        ndx := ((cc shl 2) and 0FCh);
        step := 1;
      }

      1:
      {
        ndx := ndx or ((cc shr 4) and 03h);
        result += chr(ndx);
        ndx := ((cc shl 4) and 0F0h);
        step := 2;
      }

      2:
      {
        ndx := ndx or ((cc shr 2) and 0Fh);
        result += chr(ndx);
        ndx := ((cc shl 6) and 0C0h);
        step := 3;
      }

      3:
      {
        ndx := ndx or (cc and 3Fh);
        result += chr(ndx);
        step := 0;
      }

    end;
  }
}

End.
