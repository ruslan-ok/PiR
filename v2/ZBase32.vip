VipInterface ZBase32 licensed(free);

Interface ZBase32;

Screen scTest;
Buttons
  cmOk, default;
<<

  <. Test .>
>>
End;

Const
  EncodingTable32: string = 'ybndrfg8ejkmcpqxot1uwisza345h769';
  EncodingTable64: string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
End;

var i, cc, rest_bits, rest_value, ndx: byte = 0;

private procedure EncodeOne(var _res: string);
{
  case rest_bits of

    0:
    {
      ndx := ((cc shr 3) and 1Fh);
      _res += EncodingTable32[ndx+1];
      rest_bits := 3;
      rest_value := (cc and 07h);
    }

    3:
    {
      ndx := ((rest_value shl 2) and 1Ch) or ((cc shr 6) and 03h);
      _res += EncodingTable32[ndx+1];
      ndx := ((cc shr 1) and 1Fh);
      _res += EncodingTable32[ndx+1];
      rest_bits := 1;
      rest_value := (cc and 01h);
    }

    1:
    {
      ndx := ((rest_value shl 4) and 10h) or ((cc shr 4) and 0Fh);
      _res += EncodingTable32[ndx+1];
      rest_bits := 4;
      rest_value := (cc and 0Fh);
    }

    4:
    {
      ndx := ((rest_value shl 1) and 1Eh) or ((cc shr 7) and 01h);
      _res += EncodingTable32[ndx+1];
      ndx := ((cc shr 2) and 1Fh);
      _res += EncodingTable32[ndx+1];
      rest_bits := 2;
      rest_value := (cc and 03h);
    }

    2:
    {
      ndx := ((rest_value shl 3) and 18h) or ((cc shr 5) and 07h);
      _res += EncodingTable32[ndx+1];
      ndx := (cc and 1Fh);
      _res += EncodingTable32[ndx+1];
      rest_bits := 0;
    }

  end;
}

private function Encode(_src: string): string;
{
  result := '';

  for (i := 1; i <= length(_src); i++)
  {
    cc := ord(_src[i]);
    EncodeOne(result);
  }

  if (rest_bits <> 0)
  {
    cc := 0;
    EncodeOne(result);
  }
}

private function GetPos(_value: char): byte;
{
  var k: byte;
  for (k := 1; k <= length(EncodingTable32); k++)
  {
    if (EncodingTable32[k] = _value)
    {
      result := k;
      exit;
    }
  }
  message('oops');
  result := 0;
/*
  case _value of
    'y': result := 1;
    'b': result := 2;
    'n': result := 3;
    'd': result := 4;
    'r': result := 5;
    'f': result := 6;
    'g': result := 7;
    '8': result := 8;
    'e': result := 9;
    'j': result := 10;
    'k': result := 11;
    'm': result := 12;
    'c': result := 13;
    'p': result := 14;
    'q': result := 15;
    'x': result := 16;
    'o': result := 17;
    't': result := 18;
    '1': result := 19;
    'u': result := 20;
    'w': result := 21;
    'i': result := 22;
    's': result := 23;
    'z': result := 24;
    'a': result := 25;
    '3': result := 26;
    '4': result := 27;
    '5': result := 28;
    'h': result := 29;
    '7': result := 20;
    '6': result := 31;
    '9': result := 32;
  end;
*/
}

private function Decode(_src: string): string;
{
  result := '';
  var i, cc, rest_bits, ndx: byte = 0;

  for (i := 1; i <= length(_src); i++)
  {
    cc := GetPos(_src[i]);

    if (cc = 0)
      message('oops');

    cc--;

    case rest_bits of

      0:
      {
        ndx := ((cc shl 3) and 0F8h);
        rest_bits := 3;
      }

      3:
      {
        ndx := ndx or ((cc shr 2) and 07h);
        result += chr(ndx);
        ndx := ((cc shl 6) and 0C0h);
        rest_bits := 6;
      }

      6:
      {
        ndx := ndx or ((cc shl 1) and 3Eh);
        rest_bits := 1;
      }

      1:
      {
        ndx := ndx or ((cc shr 4) and 01h);
        result += chr(ndx);
        ndx := ((cc shl 4) and 0F0h);
        rest_bits := 4;
      }

      4:
      {
        ndx := ndx or ((cc shr 1) and 0Fh);
        result += chr(ndx);
        ndx := ((cc shl 7) and 080h);
        rest_bits := 7;
      }

      7:
      {
        ndx := ndx or ((cc shl 2) and 7Ch);
        rest_bits := 2;
      }

      2:
      {
        ndx := ndx or ((cc shr 3) and 03h);
        result += chr(ndx);
        ndx := ((cc shl 5) and 0E0h);
        rest_bits := 5;
      }

      5:
      {
        ndx := ndx or (cc and 1Fh);
        result += chr(ndx);
        rest_bits := 0;
      }

    end;
  }
}

HandleEvent

cmOk:
{
  var s1, s2: string;
  s1 := Encode('Hello, World!');
  s2 := Decode(s1);
  message(s1 + ''#13 + s2);
//  message(Decode('4nq7bcgosuemmwcq4gy7ddbcrdeadwcn4napdysttuea6egosmembwfhrdemdwcm4n77bcby4n97bxsozzea9wcn4n67bcby4nhnbwf94n9pbq6oszemxwf74nanhegow8em9wfo4gy7bqgos8emhegos9emyegosmem5wfa4n6pbcgozzemtwfirr'));
}

End;

End.
