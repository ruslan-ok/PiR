//------------------------------------------------------------------------------
//                                                      (c) Корпорация Галактика
// Заработная плата по отделу
// Табличный объект отдельной выплаты
//------------------------------------------------------------------------------

#include AtlProtocol.vih

Interface Payment;

var mPrev: IPayment;

Table struct mtPayment
(
  Person: byte,
  Period: byte,
  Payed:  date,
  Sort:   byte,
  Title:  byte,
  Value:  double,
  TaxCur: byte,
  Rate:   double,
  Info:   string
)
With index
(
  Sorted = Person + Period + Sort,
  Titled = Person + Period + Title (unique),
  ByTitle = Title
);

function GetCountedValue(_PresentTaxCur: byte; _value, _rate: double; _NeededTaxCur: byte): double; forward;
var sError: string = '';

Create view as select
  GetCountedValue(mtPayment.TaxCur, mtPayment.Value, mtPayment.Rate, cgNetUSD) (FieldName = fNetUSD),
  GetCountedValue(mtPayment.TaxCur, mtPayment.Value, mtPayment.Rate, cgTaxUSD) (FieldName = fTaxUSD),
  GetCountedValue(mtPayment.TaxCur, mtPayment.Value, mtPayment.Rate, cgNetBYN) (FieldName = fNetBYN),
  GetCountedValue(mtPayment.TaxCur, mtPayment.Value, mtPayment.Rate, cgTaxBYN) (FieldName = fTaxBYN),
  *
from
  mtPayment,
  mtPayment mtPayment2;

property Person: byte   absolute mtPayment.Person;
property Period: byte   absolute mtPayment.Period;
property Payed:  date   absolute mtPayment.Payed;
property Sort:   byte   absolute mtPayment.Sort;
property Title:  byte   absolute mtPayment.Title;
property Value:  double absolute mtPayment.Value;
property TaxCur: byte   absolute mtPayment.TaxCur;
property Rate:   double absolute mtPayment.Rate;
property Info:   string absolute mtPayment.Info;
property NetBYN: double read fNetBYN;
property TaxBYN: double read fTaxBYN;
property NetUSD: double read fNetUSD;
property TaxUSD: double read fTaxUSD;
property Error:  string read sError;
property dPeriod: date  read IdToPeriod(mtPayment.Period);

index Sorted auto;
index Titled auto;
index ByTitle auto;

var TagName: string;

public function GetValue(_pers: byte; _period: date; _title: byte; _NeededTaxCur: byte): double;
{
  result := 0;

  if (GetFirst mtPayment2 where (( _pers   == mtPayment2.Person and
                                   _period == mtPayment2.Period and
                                   _title  == mtPayment2.Title )) = tsOk)
    result := GetCountedValue(mtPayment2.TaxCur, mtPayment2.Value, mtPayment2.Rate, _NeededTaxCur);
}

public function GetRate(_pers: byte; _period: date; _title: byte): double;
{
  result := 0;

  if (GetFirst mtPayment2 where (( _pers   == mtPayment2.Person and
                                   _period == mtPayment2.Period and
                                   _title  == mtPayment2.Title )) = tsOk)
    result := mtPayment2.Rate;
}

public function GetInfo(_pers: byte; _period: date; _title: byte): string;
{
  result := '';

  if (GetFirst mtPayment2 where (( _pers   == mtPayment2.Person and
                                   _period == mtPayment2.Period and
                                   _title  == mtPayment2.Title )) = tsOk)
    result := mtPayment2.Info;
}

public function GetPayed(_pers: byte; _period: date; _title: byte): date;
{
  result := ZeroDate;

  if (GetFirst mtPayment2 where (( _pers   == mtPayment2.Person and
                                   _period == mtPayment2.Period and
                                   _title  == mtPayment2.Title )) = tsOk)
    result := mtPayment2.Payed;
}

public function GetTitleName: string;
{
  result := '';
  if (oWage <> NullRef)
    result := oWage.GetTitleName(mtPayment.Title);
}

public function ToString: string;
{
  result := string(Value) + ' ' + if(TaxCur = cgNetUSD or TaxCur = cgTaxUSD, 'USD', 'BYN') + ' ' + GetTitleName;
}

function IModify.doInsert : word;
{
  result := insert current mtPayment;
}

function IModify.doUpdate : word;
{
  result := update current mtPayment;
}

function IModify.doDelete : word;
{
  result := delete current mtPayment;
}

implementation IModify.doFlush abstract;

constructor Init;
{
  result := true;
  delete all mtPayment;
  TagName := 'rok:Payment';
}

private function GetCountedValue(_PresentTaxCur: byte; _value, _rate: double; _NeededTaxCur: byte): double;
{
  result := 0;

  case _NeededTaxCur of

    cgNetBYN:
      case _PresentTaxCur of
        cgNetBYN: result := _value;
        cgTaxBYN: result := _value * 1.09;
        cgNetUSD: result := _value * _rate;
        cgTaxUSD: result := _value * 1.09 * _rate;
      end;

    cgTaxBYN:
      case _PresentTaxCur of
        cgNetBYN: result := _value * 0.91;
        cgTaxBYN: result := _value;
        cgNetUSD: result := _value * 0.91 * _rate;
        cgTaxUSD: result := _value * _rate;
      end;

    cgNetUSD:
      case _PresentTaxCur of
        cgNetBYN: result := _value / _rate;
        cgTaxBYN: result := _value * 1.09 / _rate;
        cgNetUSD: result := _value;
        cgTaxUSD: result := _value * 1.09;
      end;

    cgTaxUSD:
      case _PresentTaxCur of
        cgNetBYN: result := _value * 0.91 / _rate;
        cgTaxBYN: result := _value / _rate;
        cgNetUSD: result := _value * 0.91;
        cgTaxUSD: result := _value;
      end;

  end;
}

public procedure Clear(_wage: IWageView = NullRef);
{
  oWage := _wage;
  delete all mtPayment;
}

public function SaveXml(_e: IDomNode): IDomNode;
{
  var xnode: IDomNode
  xnode := _e.AddNode(TagName);
  xnode.AddAttr('rok:Payed='  + string(Payed));
  xnode.AddAttr('rok:Sort='   + string(Sort));
  xnode.AddAttr('rok:Title='  + string(Title));
  xnode.AddAttr('rok:Value='  + DoubleToStr(Value, '\2p[|-]3666666666666~99'));
  xnode.AddAttr('rok:TaxCur=' + string(TaxCur));
  xnode.AddAttr('rok:Rate='   + DoubleToStr(Rate, '\4p[|-]3666666666~9999'));
  xnode.AddAttr('rok:Info='   + Info);
  result := xnode;
}

public function LoadXml(_e: IDomNode): boolean;
{
  result := false;

  if (_e.Name <> TagName)
    exit;

  ClearBuffer(#mtPayment);
  if _e.GetFirstAttr
    do
    {
      case _e.FndAttr.Name of
        'rok:Payed':  Payed  := StrToDate(_e.FndAttr.Value, 'DD/MM/YYYY');
        'rok:Sort':   Sort   := byte(_e.FndAttr.Value);
        'rok:Title':  Title  := GetTitleId(_e.FndAttr.Value);
        'rok:Value':  Value  := double(_e.FndAttr.Value);
        'rok:TaxCur': TaxCur := byte(_e.FndAttr.Value);
        'rok:Rate':   Rate   := double(_e.FndAttr.Value);
        'rok:Info':   Info   := _e.FndAttr.Value;
      end;
    }
    while (_e.GetNextAttr);

  Person := oWage.PersonId;
  Period := oWage.PeriodId;

  if (GetFirst mtPayment2 where (( mtPayment.Person == mtPayment2.Person and
                                   mtPayment.Period == mtPayment2.Period and
                                   mtPayment.Title  == mtPayment2.Title )) = tsOk)
  {
    oWage.Log(APE_WARNING, 'Запись уже существует: ' + ToString);
  }
  else
  {
    var res: word;
    res := insert current mtPayment;
    if (res <> tsOk)
      oWage.Log(APE_WARNING, 'Error on insert: ' + ToString);
    else
      oWage.Log(APE_INFO, ToString);
  }

  result := true;
}

public function SaveRok: boolean;
{
  result := true;
  StartNewRec;
  WriteDate(Payed);
  WriteByte(Sort);
  WriteByte(Title);
  WriteDouble(Value);
  WriteByte(TaxCur);
  WriteDouble(Rate);
  WriteStr(Info);
}

public function LoadRok: boolean;
{
  result := false;

  if CheckNewRec
  {
    ClearBuffer(#mtPayment);
    Payed  := ReadDate;
    Sort   := ReadByte;
    Title  := ReadByte;
    Value  := ReadDouble;
    TaxCur := ReadByte;
    Rate   := ReadDouble;
    Info   := ReadStr;
    Person := oWage.PersonId;
    Period := oWage.PeriodId;

    if (GetFirst mtPayment2 where (( mtPayment.Person == mtPayment2.Person and
                                     mtPayment.Period == mtPayment2.Period and
                                     mtPayment.Title  == mtPayment2.Title )) = tsOk)
    {
      oWage.Log(APE_WARNING, 'Запись уже существует: ' + ToString);
    }
    else
    {
      insert current mtPayment;
      oWage.Log(APE_INFO, ToString);
    }

    result := true;
  }
}

end.
